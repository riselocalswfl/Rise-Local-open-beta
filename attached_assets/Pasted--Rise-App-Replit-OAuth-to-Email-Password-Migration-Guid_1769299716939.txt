# Rise App: Replit OAuth to Email/Password Migration Guide

## Executive Summary

This guide provides a complete migration strategy to transition existing Replit OAuth users to the new email/password authentication system before your App Store launch. The approach ensures zero data loss and minimal user friction.

---

## Migration Strategy Overview

### Goals
1. Preserve all existing user data and relationships
2. Maintain seamless user experience
3. Ensure security throughout the migration
4. Provide clear communication to users
5. Complete migration before App Store launch

### Approach: Forced Password Creation on Next Login

The recommended approach is a **just-in-time migration** where Replit OAuth users are prompted to create a password the first time they log in after the migration is deployed.

**Why this approach:**
- âœ… Zero data loss - uses existing email addresses
- âœ… User-initiated - only migrates active users
- âœ… Secure - users create their own passwords
- âœ… Gradual - no hard cutoff date needed
- âœ… Simple - minimal code changes required

---

## Current Database State

### User Table Structure
```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255),  -- NULL for OAuth users
  firstName VARCHAR(255),
  lastName VARCHAR(255),
  role VARCHAR(50),
  isVendor BOOLEAN DEFAULT false,
  isAdmin BOOLEAN DEFAULT false,
  emailVerified BOOLEAN DEFAULT false,
  failedLoginAttempts INTEGER DEFAULT 0,
  lockedUntil TIMESTAMP,
  replitId VARCHAR(255),  -- Legacy OAuth identifier
  accountType VARCHAR(50)
);
```

### Identifying Legacy Users
Users need migration if:
- `replitId` IS NOT NULL
- `password` IS NULL

---

## Implementation Steps

### Phase 1: Pre-Migration Setup (Week 1)

#### Step 1.1: Database Audit
```sql
-- Count users needing migration
SELECT COUNT(*) as oauth_users
FROM users
WHERE replitId IS NOT NULL AND password IS NULL;

-- Verify all have email addresses
SELECT COUNT(*) as missing_email
FROM users
WHERE replitId IS NOT NULL AND email IS NULL;

-- Export user list for communication
SELECT id, email, firstName, lastName, role
FROM users
WHERE replitId IS NOT NULL AND password IS NULL
ORDER BY email;
```

#### Step 1.2: Add Migration Tracking Column
```sql
-- Add column to track migration status
ALTER TABLE users
ADD COLUMN migrationRequired BOOLEAN DEFAULT false;

-- Mark existing OAuth users
UPDATE users
SET migrationRequired = true
WHERE replitId IS NOT NULL AND password IS NULL;

-- Add index for quick lookups
CREATE INDEX idx_migration_required ON users(migrationRequired);
```

#### Step 1.3: Create Migration Log Table
```sql
CREATE TABLE migration_log (
  id SERIAL PRIMARY KEY,
  userId INTEGER REFERENCES users(id),
  action VARCHAR(100),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  ipAddress VARCHAR(45),
  userAgent TEXT,
  success BOOLEAN,
  notes TEXT
);

CREATE INDEX idx_migration_user ON migration_log(userId);
CREATE INDEX idx_migration_timestamp ON migration_log(timestamp);
```

### Phase 2: Backend Implementation (Week 1-2)

#### Step 2.1: Create Password Creation Endpoint

Create a new endpoint for legacy users to set their password:

```javascript
// routes/auth/setPassword.js
const bcrypt = require('bcrypt');
const db = require('../db');

async function setPassword(req, res) {
  try {
    const { userId, password } = req.body;

    // Validate password strength
    if (!password || password.length < 8) {
      return res.status(400).json({
        error: 'Password must be at least 8 characters long'
      });
    }

    // Verify user needs migration
    const userResult = await db.query(
      'SELECT id, email, migrationRequired FROM users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const user = userResult.rows[0];

    if (!user.migrationRequired) {
      return res.status(400).json({
        error: 'Password already set for this account'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Update user record
    await db.query(
      `UPDATE users
       SET password = $1,
           migrationRequired = false,
           emailVerified = true
       WHERE id = $2`,
      [hashedPassword, userId]
    );

    // Log migration
    await db.query(
      `INSERT INTO migration_log (userId, action, success, notes)
       VALUES ($1, 'password_set', true, 'User completed migration')`,
      [userId]
    );

    res.json({
      success: true,
      message: 'Password successfully created'
    });

  } catch (error) {
    console.error('Set password error:', error);

    // Log failed attempt
    if (req.body.userId) {
      await db.query(
        `INSERT INTO migration_log (userId, action, success, notes)
         VALUES ($1, 'password_set', false, $2)`,
        [req.body.userId, error.message]
      );
    }

    res.status(500).json({
      error: 'Failed to set password'
    });
  }
}

module.exports = setPassword;
```

#### Step 2.2: Modify Replit OAuth Callback

Update your OAuth callback to check migration status:

```javascript
// routes/auth/replitCallback.js
async function replitOAuthCallback(req, res) {
  try {
    // Get user info from Replit OAuth
    const replitUser = await getReplitUserInfo(req.query.code);

    // Find user by replitId
    const userResult = await db.query(
      'SELECT * FROM users WHERE replitId = $1',
      [replitUser.id]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({
        error: 'User not found'
      });
    }

    const user = userResult.rows[0];

    // Check if migration required
    if (user.migrationRequired) {
      // Generate temporary session token
      const tempToken = generateTempToken(user.id);

      // Redirect to password creation page
      return res.redirect(
        `/migration/set-password?token=${tempToken}&email=${encodeURIComponent(user.email)}`
      );
    }

    // Normal login flow for migrated users
    const token = generateJWT(user);
    res.json({ token, user });

  } catch (error) {
    console.error('OAuth callback error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
}
```

#### Step 2.3: Create Temporary Token System

For the migration flow, you'll need temporary tokens:

```javascript
// utils/tempToken.js
const crypto = require('crypto');
const db = require('../db');

// Store temp tokens in database or Redis (expires in 1 hour)
async function generateTempToken(userId) {
  const token = crypto.randomBytes(32).toString('hex');
  const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

  await db.query(
    `INSERT INTO temp_tokens (token, userId, expiresAt, purpose)
     VALUES ($1, $2, $3, 'migration')`,
    [token, userId, expiresAt]
  );

  return token;
}

async function validateTempToken(token) {
  const result = await db.query(
    `SELECT userId FROM temp_tokens
     WHERE token = $1
       AND expiresAt > NOW()
       AND purpose = 'migration'
       AND used = false`,
    [token]
  );

  if (result.rows.length === 0) {
    return null;
  }

  // Mark as used
  await db.query(
    'UPDATE temp_tokens SET used = true WHERE token = $1',
    [token]
  );

  return result.rows[0].userId;
}

module.exports = { generateTempToken, validateTempToken };
```

#### Step 2.4: Add Temp Tokens Table

```sql
CREATE TABLE temp_tokens (
  id SERIAL PRIMARY KEY,
  token VARCHAR(255) UNIQUE NOT NULL,
  userId INTEGER REFERENCES users(id),
  purpose VARCHAR(50) NOT NULL,
  createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expiresAt TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT false
);

CREATE INDEX idx_temp_token ON temp_tokens(token);
CREATE INDEX idx_temp_token_expiry ON temp_tokens(expiresAt);
```

### Phase 3: Frontend Implementation (Week 2)

#### Step 3.1: Create Password Setup Page

```jsx
// pages/migration/SetPassword.jsx
import { useState } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';

export default function SetPassword() {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const token = searchParams.get('token');
  const email = searchParams.get('email');

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    // Validate passwords match
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    // Validate password strength
    if (password.length < 8) {
      setError('Password must be at least 8 characters');
      return;
    }

    setLoading(true);

    try {
      // Validate token and get userId
      const validateRes = await fetch('/api/auth/validate-migration-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ token })
      });

      if (!validateRes.ok) {
        throw new Error('Invalid or expired token');
      }

      const { userId } = await validateRes.json();

      // Set password
      const setPasswordRes = await fetch('/api/auth/set-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, password })
      });

      if (!setPasswordRes.ok) {
        const data = await setPasswordRes.json();
        throw new Error(data.error || 'Failed to set password');
      }

      // Auto-login after successful migration
      const loginRes = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      if (loginRes.ok) {
        const { token } = await loginRes.json();
        localStorage.setItem('authToken', token);
        navigate('/dashboard');
      }

    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="migration-container">
      <div className="migration-card">
        <h1>Welcome Back to Rise!</h1>
        <p className="migration-message">
          We've upgraded our authentication system. Please create a password
          for your account to continue.
        </p>

        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label>Email</label>
            <input
              type="email"
              value={email}
              disabled
              className="form-control"
            />
          </div>

          <div className="form-group">
            <label>New Password</label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Minimum 8 characters"
              required
              className="form-control"
            />
          </div>

          <div className="form-group">
            <label>Confirm Password</label>
            <input
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              placeholder="Re-enter password"
              required
              className="form-control"
            />
          </div>

          {error && <div className="error-message">{error}</div>}

          <button
            type="submit"
            disabled={loading}
            className="btn btn-primary"
          >
            {loading ? 'Setting Password...' : 'Create Password & Continue'}
          </button>
        </form>

        <div className="migration-help">
          <p>Need help? Contact support@rise.app</p>
        </div>
      </div>
    </div>
  );
}
```

#### Step 3.2: Add Route

```jsx
// App.jsx or router config
import SetPassword from './pages/migration/SetPassword';

// Add route
<Route path="/migration/set-password" element={<SetPassword />} />
```

### Phase 4: User Communication (Week 2-3)

#### Step 4.1: Email Notification Template

Send this email to all users with `migrationRequired = true`:

```
Subject: Important: Update Your Rise Account

Hi [First Name],

We're excited to share that Rise is launching on the App Store soon!

To prepare for this launch, we're upgrading our authentication system. The next time you log in, you'll be prompted to create a password for your account.

What you need to do:
1. Visit rise.app and click "Sign in with Replit Account"
2. You'll be redirected to create a password
3. Use this new password for all future logins

Your email address will remain: [email]

This one-time step ensures your account is ready for the App Store version and provides enhanced security.

Questions? Reply to this email or visit our help center.

Thanks for being part of Rise!

The Rise Team
```

#### Step 4.2: In-App Banner

For users still using Replit OAuth, show a banner:

```jsx
// components/MigrationBanner.jsx
export default function MigrationBanner({ user }) {
  if (!user.migrationRequired) return null;

  return (
    <div className="migration-banner">
      <div className="banner-content">
        <strong>Action Required:</strong> Please create a password for your account.
        The next time you log in, you'll be prompted to set up your password.
      </div>
    </div>
  );
}
```

### Phase 5: Cleanup (Week 4+)

#### Step 5.1: Monitor Migration Progress

```sql
-- Check migration status
SELECT
  COUNT(*) FILTER (WHERE migrationRequired = true) as pending,
  COUNT(*) FILTER (WHERE migrationRequired = false) as completed,
  COUNT(*) as total
FROM users
WHERE replitId IS NOT NULL;

-- Recent migrations
SELECT
  u.email,
  m.timestamp,
  m.success
FROM migration_log m
JOIN users u ON m.userId = u.id
WHERE m.action = 'password_set'
ORDER BY m.timestamp DESC
LIMIT 20;
```

#### Step 5.2: Final Cutoff (Optional)

After 30-60 days, you can force remaining users:

```sql
-- Find inactive users who haven't migrated
SELECT email, firstName, lastName
FROM users
WHERE migrationRequired = true
  AND lastLoginAt < NOW() - INTERVAL '30 days';
```

Options for stragglers:
1. **Email password reset link** - Force password creation via reset flow
2. **Lock accounts** - Require support contact to reactivate
3. **Send final reminder** - Give 2-week deadline

#### Step 5.3: Remove Replit OAuth (After 100% Migration)

```javascript
// Only after ALL users migrated:

// 1. Remove Replit OAuth routes
// routes/auth/replitOAuth.js - DELETE
// routes/auth/replitCallback.js - DELETE

// 2. Remove frontend login button
// components/Login.jsx - Remove "Sign in with Replit" button

// 3. Clean up database (OPTIONAL - keep for historical records)
// ALTER TABLE users DROP COLUMN replitId;
// DROP TABLE temp_tokens;
```

---

## Security Considerations

### Password Requirements
Enforce these requirements in your validation:
- Minimum 8 characters
- At least one uppercase letter
- At least one number
- At least one special character (optional)

```javascript
function validatePassword(password) {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasNumber = /[0-9]/.test(password);

  if (password.length < minLength) {
    return 'Password must be at least 8 characters';
  }
  if (!hasUpperCase) {
    return 'Password must contain at least one uppercase letter';
  }
  if (!hasNumber) {
    return 'Password must contain at least one number';
  }
  return null;
}
```

### Rate Limiting
Protect the password creation endpoint:

```javascript
// Limit to 5 attempts per hour per IP
const rateLimit = require('express-rate-limit');

const setPasswordLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5,
  message: 'Too many password creation attempts, please try again later'
});

app.post('/api/auth/set-password', setPasswordLimiter, setPassword);
```

### Token Security
- Temporary tokens expire in 1 hour
- Single-use only (marked as used)
- Cryptographically secure random generation
- Stored with userId reference

---

## Testing Checklist

### Pre-Deployment Testing

- [ ] Create test user with `replitId` and no password
- [ ] Verify OAuth login redirects to password creation
- [ ] Test password validation (length, strength)
- [ ] Test password mismatch error
- [ ] Verify auto-login after password creation
- [ ] Test expired token handling
- [ ] Test already-migrated user (should skip to normal login)
- [ ] Verify database updates correctly
- [ ] Check migration_log entries created
- [ ] Test rate limiting on password endpoint
- [ ] Verify email notifications send correctly

### Production Monitoring

```sql
-- Daily migration stats
SELECT
  DATE(timestamp) as date,
  COUNT(*) as migrations,
  COUNT(*) FILTER (WHERE success = true) as successful,
  COUNT(*) FILTER (WHERE success = false) as failed
FROM migration_log
WHERE action = 'password_set'
  AND timestamp > NOW() - INTERVAL '7 days'
GROUP BY DATE(timestamp)
ORDER BY date DESC;
```

---

## Rollback Plan

If issues arise during migration:

### Emergency Rollback Steps

1. **Disable password creation page**
   ```javascript
   // Add feature flag
   const MIGRATION_ENABLED = false;

   if (!MIGRATION_ENABLED) {
     return res.redirect('/login');
   }
   ```

2. **Revert OAuth callback**
   ```javascript
   // Skip migration check temporarily
   // if (user.migrationRequired) {
   //   return res.redirect('/migration/set-password');
   // }

   // Allow normal OAuth login
   const token = generateJWT(user);
   res.json({ token, user });
   ```

3. **Communicate with users**
   - Send email explaining temporary issue
   - Provide timeline for resolution
   - Ensure OAuth login still works

---

## Timeline Summary

| Week | Phase | Tasks |
|------|-------|-------|
| Week 1 | Pre-Migration | Database audit, add tracking columns, create migration log |
| Week 1-2 | Backend | Implement password creation endpoint, modify OAuth callback, create temp token system |
| Week 2 | Frontend | Build password setup page, add routing, create migration banner |
| Week 2-3 | Communication | Send email notifications, deploy in-app banners |
| Week 3-4 | Monitoring | Track migration progress, provide support, handle edge cases |
| Week 4+ | Cleanup | Force remaining migrations, remove OAuth code (after 100% complete) |

---

## Support FAQs

**Q: Why do I need to create a password?**
A: We're upgrading our authentication system to support the Rise app on the App Store. This one-time step ensures your account works seamlessly across all platforms.

**Q: Will I lose any data?**
A: No! All your data, preferences, and history remain intact. You're simply adding a password to your existing account.

**Q: What if I forget my password?**
A: Use the "Forgot Password" link on the login page to reset it via email.

**Q: Can I still use my Replit account?**
A: For a transition period, yes. But we encourage you to create a password soon as Replit login will be phased out.

**Q: What password should I use?**
A: Create a strong, unique password with at least 8 characters, including uppercase letters and numbers.

---

## Success Metrics

Track these KPIs:

1. **Migration Rate**: % of users who have created passwords
2. **Time to Migrate**: Average days from notification to completion
3. **Support Tickets**: Number of migration-related issues
4. **Failed Attempts**: Rate limiting hits, token expirations
5. **User Retention**: Ensure migration doesn't cause user drop-off

Target: 90%+ migration within 30 days

---

## Contact & Support

For implementation questions or issues during migration:
- Technical Lead: [Your Name]
- Database Admin: [Name]
- Support Team: support@rise.app

---

## Appendix: SQL Scripts

### Full Migration Setup Script

```sql
-- Add migration tracking
ALTER TABLE users ADD COLUMN migrationRequired BOOLEAN DEFAULT false;
UPDATE users SET migrationRequired = true WHERE replitId IS NOT NULL AND password IS NULL;
CREATE INDEX idx_migration_required ON users(migrationRequired);

-- Create migration log
CREATE TABLE migration_log (
  id SERIAL PRIMARY KEY,
  userId INTEGER REFERENCES users(id),
  action VARCHAR(100),
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  ipAddress VARCHAR(45),
  userAgent TEXT,
  success BOOLEAN,
  notes TEXT
);
CREATE INDEX idx_migration_user ON migration_log(userId);
CREATE INDEX idx_migration_timestamp ON migration_log(timestamp);

-- Create temp tokens
CREATE TABLE temp_tokens (
  id SERIAL PRIMARY KEY,
  token VARCHAR(255) UNIQUE NOT NULL,
  userId INTEGER REFERENCES users(id),
  purpose VARCHAR(50) NOT NULL,
  createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expiresAt TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT false
);
CREATE INDEX idx_temp_token ON temp_tokens(token);
CREATE INDEX idx_temp_token_expiry ON temp_tokens(expiresAt);
```

### Cleanup Script (After 100% Migration)

```sql
-- Verify all users migrated
SELECT COUNT(*) FROM users WHERE migrationRequired = true;

-- If zero, proceed with cleanup
ALTER TABLE users DROP COLUMN migrationRequired;
DROP TABLE temp_tokens;

-- Optional: Remove replitId (keep for historical records)
-- ALTER TABLE users DROP COLUMN replitId;
```

---

## End of Guide

This migration strategy ensures a smooth transition from Replit OAuth to email/password authentication while maintaining data integrity and user trust. Follow each phase carefully and monitor progress throughout the migration period.

Good luck with your App Store launch! ðŸš€